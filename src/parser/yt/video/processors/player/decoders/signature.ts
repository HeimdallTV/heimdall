/**
 * On top of the n parameter, some videos are passed from the player with a signature.
 * The value of this signature is generated by the backend based off the signatureTimestamp
 * found in the base.js and passed during the /player fetch request
 * We must take the parameter and decode it using other functions found in the base.js
 * Failure to do this results in a 403
 **/
import { createStorageProvider, memoizeAsync } from '@/libs/cache'
import { fetchBaseJS } from './shared'

export const getSigTimestamp = memoizeAsync(
	() => fetchBaseJS().then((js) => js.match(/signatureTimestamp:(\d+)/)![1]),
	{ provider: createStorageProvider('YT_SIG_TIMESTAMP'), timeout: 1000 * 60 * 60 * 24 },
)

export const getSigFunction = memoizeAsync(async () => {
	const baseJS = await fetchBaseJS()

	const transformFunctionName = baseJS.match(/[a-z]=(\w+)\(decodeURIComponent/)![1]
	const transformFunctionBody = `var ${
		baseJS.match(new RegExp(`${transformFunctionName}=function\\(.+?\\){[^]+?};`))![0]
	}`

	const helperFunctionName = transformFunctionBody.match(/;(\w+)\.[\w\d]+\([a-z],\d+\);/)![1]
	const helperFunctionBody = baseJS.match(new RegExp(`var ${helperFunctionName}={[\\S\\s]+?};`))!

	return {
		code: [transformFunctionBody, helperFunctionBody].join('\n'),
		funcName: transformFunctionName,
	}
})

export const getDecodedSigParam = (sig: string) =>
	getSigFunction().then(({ code, funcName }) => eval(`${code}\n${funcName}("${sig}")`))
