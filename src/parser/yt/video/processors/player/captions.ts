import { PlayerCaptionsTracklist } from '@yt/video/types/captions'
import * as std from '@std'
import { fetchProxy } from '@libs/extension'
import { TimedText, TimedTextSegmentEvent } from '../../types/responses/timed-text'

export const processCaptions = (captions: PlayerCaptionsTracklist): std.ClosedCaption[] => {
  const renderer = captions.playerCaptionsTracklistRenderer
  const defaultCaptionIndex = renderer.audioTracks[renderer.defaultAudioTrackIndex].defaultCaptionTrackIndex
  return renderer.captionTracks.map((caption, i) => {
    if (isAutoGenerated(caption.vssId)) {
      return {
        type: std.ClosedCaptionType.Overlapping,
        language: caption.languageCode,
        isDefault: i === defaultCaptionIndex,
        getTrack: () =>
          fetchProxy(convertToJSONUrl(caption.baseUrl))
            .then(res => res.json())
            .then(parseAutoGeneratedCaptions)
            .then(val => {
              console.log(val)
              return val
            }),
      }
    }
    return {
      type: std.ClosedCaptionType.Default,
      language: caption.languageCode,
      isDefault: i === defaultCaptionIndex,
      getTrack: () =>
        fetchProxy(convertToJSONUrl(caption.baseUrl))
          .then(res => res.json())
          .then(parseCaptions),
    }
  })
}

/** See comment on vssId for more info */
const isAutoGenerated = (vssId: string) => vssId.startsWith('a.')

/** Youtube by default returns an XML URL but adding `&fmt=json3` to the end of the URL will return JSON */
const convertToJSONUrl = (url: string) => {
  const urlObj = new URL(url)
  urlObj.searchParams.set('fmt', 'json3')
  return urlObj.toString()
}

const parseAutoGeneratedCaptions = (timedText: TimedText): std.ClosedCaptionTrackCueLine[] => {
  const events = timedText.events.filter((event): event is TimedTextSegmentEvent => 'segs' in event)
  return events
    .filter(event => event.segs.length > 1 || event.segs[0].utf8.trim().length > 0)
    .flatMap<std.ClosedCaptionTrackCueLine>(event => ({
      startTimeMS: event.tStartMs,
      endTimeMS: event.tStartMs + event.dDurationMs,
      words: event.segs.map(seg => ({
        text: seg.utf8,
        startTimeMS: event.tStartMs + (seg.tOffsetMs ?? 0),
      })),
    }))
}

const parseCaptions = (timedText: TimedText): std.ClosedCaptionTrackCue[] =>
  timedText.events
    .filter((event): event is TimedTextSegmentEvent => 'segs' in event)
    .flatMap<std.ClosedCaptionTrackCue>(event => ({
      startTimeMS: event.tStartMs,
      endTimeMS: event.tStartMs + event.dDurationMs,
      text: event.segs.map(seg => seg.utf8).join(''),
    }))
